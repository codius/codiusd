<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>GNU Parallel alternatives</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DIFFERENCES-BETWEEN-GNU-Parallel-AND-ALTERNATIVES">DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES</a>
    <ul>
      <li><a href="#SUMMARY-TABLE">SUMMARY TABLE</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-xargs-AND-GNU-Parallel">DIFFERENCES BETWEEN xargs AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-find--exec-AND-GNU-Parallel">DIFFERENCES BETWEEN find -exec AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-make--j-AND-GNU-Parallel">DIFFERENCES BETWEEN make -j AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-ppss-AND-GNU-Parallel">DIFFERENCES BETWEEN ppss AND GNU Parallel</a>
        <ul>
          <li><a href="#EXAMPLES-FROM-ppss-MANUAL">EXAMPLES FROM ppss MANUAL</a></li>
        </ul>
      </li>
      <li><a href="#DIFFERENCES-BETWEEN-pexec-AND-GNU-Parallel">DIFFERENCES BETWEEN pexec AND GNU Parallel</a>
        <ul>
          <li><a href="#EXAMPLES-FROM-pexec-MANUAL">EXAMPLES FROM pexec MANUAL</a></li>
        </ul>
      </li>
      <li><a href="#DIFFERENCES-BETWEEN-xjobs-AND-GNU-Parallel">DIFFERENCES BETWEEN xjobs AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-prll-AND-GNU-Parallel">DIFFERENCES BETWEEN prll AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-dxargs-AND-GNU-Parallel">DIFFERENCES BETWEEN dxargs AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-mdm-middleman-AND-GNU-Parallel">DIFFERENCES BETWEEN mdm/middleman AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-xapply-AND-GNU-Parallel">DIFFERENCES BETWEEN xapply AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-AIX-apply-AND-GNU-Parallel">DIFFERENCES BETWEEN AIX apply AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-paexec-AND-GNU-Parallel">DIFFERENCES BETWEEN paexec AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-map-sitaramc-AND-GNU-Parallel">DIFFERENCES BETWEEN map(sitaramc) AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-ladon-AND-GNU-Parallel">DIFFERENCES BETWEEN ladon AND GNU Parallel</a>
        <ul>
          <li><a href="#EXAMPLES-FROM-ladon-MANUAL">EXAMPLES FROM ladon MANUAL</a></li>
        </ul>
      </li>
      <li><a href="#DIFFERENCES-BETWEEN-jobflow-AND-GNU-Parallel">DIFFERENCES BETWEEN jobflow AND GNU Parallel</a>
        <ul>
          <li><a href="#EXAMPLES-FROM-jobflow-README">EXAMPLES FROM jobflow README</a></li>
        </ul>
      </li>
      <li><a href="#DIFFERENCES-BETWEEN-gargs-AND-GNU-Parallel">DIFFERENCES BETWEEN gargs AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-orgalorg-AND-GNU-Parallel">DIFFERENCES BETWEEN orgalorg AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-Rust-parallel-AND-GNU-Parallel">DIFFERENCES BETWEEN Rust parallel AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-Rush-AND-GNU-Parallel">DIFFERENCES BETWEEN Rush AND GNU Parallel</a>
        <ul>
          <li><a href="#EXAMPLES">EXAMPLES</a></li>
          <li><a href="#Other-rush-features">Other rush features</a></li>
        </ul>
      </li>
      <li><a href="#DIFFERENCES-BETWEEN-ClusterSSH-AND-GNU-Parallel">DIFFERENCES BETWEEN ClusterSSH AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-coshell-AND-GNU-Parallel">DIFFERENCES BETWEEN coshell AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-spread-AND-GNU-Parallel">DIFFERENCES BETWEEN spread AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-pyargs-AND-GNU-Parallel">DIFFERENCES BETWEEN pyargs AND GNU Parallel</a>
        <ul>
          <li><a href="#Examples">Examples</a></li>
        </ul>
      </li>
      <li><a href="#DIFFERENCES-BETWEEN-concurrently-AND-GNU-Parallel">DIFFERENCES BETWEEN concurrently AND GNU Parallel</a></li>
      <li><a href="#DIFFERENCES-BETWEEN-map-soveran-AND-GNU-Parallel">DIFFERENCES BETWEEN map(soveran) AND GNU Parallel</a></li>
      <li><a href="#Todo">Todo</a></li>
    </ul>
  </li>
  <li><a href="#TESTING-OTHER-TOOLS">TESTING OTHER TOOLS</a>
    <ul>
      <li><a href="#MIX:-Output-mixes">MIX: Output mixes</a></li>
      <li><a href="#RAM:-Output-limited-by-RAM">RAM: Output limited by RAM</a></li>
      <li><a href="#DISKFULL:-Incomplete-data-if-tmp-runs-full">DISKFULL: Incomplete data if /tmp runs full</a></li>
      <li><a href="#CLEANUP:-Leaving-tmp-files-at-unexpected-death">CLEANUP: Leaving tmp files at unexpected death</a></li>
      <li><a href="#SPCCHAR:-Dealing-badly-with-special-file-names">SPCCHAR: Dealing badly with special file names.</a></li>
      <li><a href="#COMPOSED:-Composed-commands-do-not-work">COMPOSED: Composed commands do not work</a></li>
      <li><a href="#ONEREP:-Only-one-replacement-string-allowed">ONEREP: Only one replacement string allowed</a></li>
      <li><a href="#NUMWORDS:-Speed-depends-on-number-of-words">NUMWORDS: Speed depends on number of words</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#LICENSE">LICENSE</a>
    <ul>
      <li><a href="#Documentation-license-I">Documentation license I</a></li>
      <li><a href="#Documentation-license-II">Documentation license II</a></li>
    </ul>
  </li>
  <li><a href="#DEPENDENCIES">DEPENDENCIES</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>parallel_alternatives - Alternatives to GNU <b>parallel</b></p>

<h1 id="DIFFERENCES-BETWEEN-GNU-Parallel-AND-ALTERNATIVES">DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES</h1>

<p>There are a lot programs with some of the functionality of GNU <b>parallel</b>. GNU <b>parallel</b> strives to include the best of the functionality without sacrificing ease of use.</p>

<h2 id="SUMMARY-TABLE">SUMMARY TABLE</h2>

<p>The following features are in some of the comparable tools:</p>

<p>Inputs I1. Arguments can be read from stdin I2. Arguments can be read from a file I3. Arguments can be read from multiple files I4. Arguments can be read from command line I5. Arguments can be read from a table I6. Arguments can be read from the same file using #! (shebang) I7. Line oriented input as default (Quoting of special chars not needed)</p>

<p>Manipulation of input M1. Composed command M2. Multiple arguments can fill up an execution line M3. Arguments can be put anywhere in the execution line M4. Multiple arguments can be put anywhere in the execution line M5. Arguments can be replaced with context M6. Input can be treated as the complete command line</p>

<p>Outputs O1. Grouping output so output from different jobs do not mix O2. Send stderr (standard error) to stderr (standard error) O3. Send stdout (standard output) to stdout (standard output) O4. Order of output can be same as order of input O5. Stdout only contains stdout (standard output) from the command O6. Stderr only contains stderr (standard error) from the command</p>

<p>Execution E1. Running jobs in parallel E2. List running jobs E3. Finish running jobs, but do not start new jobs E4. Number of running jobs can depend on number of cpus E5. Finish running jobs, but do not start new jobs after first failure E6. Number of running jobs can be adjusted while running</p>

<p>Remote execution R1. Jobs can be run on remote computers R2. Basefiles can be transferred R3. Argument files can be transferred R4. Result files can be transferred R5. Cleanup of transferred files R6. No config files needed R7. Do not run more than SSHD&#39;s MaxStartups can handle R8. Configurable SSH command R9. Retry if connection breaks occasionally</p>

<p>Semaphore S1. Possibility to work as a mutex S2. Possibility to work as a counting semaphore</p>

<p>Legend - = no x = not applicable ID = yes</p>

<p>As every new version of the programs are not tested the table may be outdated. Please file a bug-report if you find errors (See REPORTING BUGS).</p>

<p>parallel: I1 I2 I3 I4 I5 I6 I7 M1 M2 M3 M4 M5 M6 O1 O2 O3 O4 O5 O6 E1 E2 E3 E4 E5 E6 R1 R2 R3 R4 R5 R6 R7 R8 R9 S1 S2</p>

<p>xargs: I1 I2 - - - - - - M2 M3 - - - - O2 O3 - O5 O6 E1 - - - - - - - - - - x - - - - -</p>

<p>find -exec: - - - x - x - - M2 M3 - - - - - O2 O3 O4 O5 O6 - - - - - - - - - - - - - - - - x x</p>

<p>make -j: - - - - - - - - - - - - - O1 O2 O3 - x O6 E1 - - - E5 - - - - - - - - - - - -</p>

<p>ppss: I1 I2 - - - - I7 M1 - M3 - - M6 O1 - - x - - E1 E2 ?E3 E4 - - R1 R2 R3 R4 - - ?R7 ? ? - -</p>

<p>pexec: I1 I2 - I4 I5 - - M1 - M3 - - M6 O1 O2 O3 - O5 O6 E1 - - E4 - E6 R1 - - - - R6 - - - S1 -</p>

<p>xjobs, prll, dxargs, mdm/middelman, xapply, paexec, ladon, jobflow, ClusterSSH: TODO - Please file a bug-report if you know what features they support (See REPORTING BUGS).</p>

<h2 id="DIFFERENCES-BETWEEN-xargs-AND-GNU-Parallel">DIFFERENCES BETWEEN xargs AND GNU Parallel</h2>

<p><b>xargs</b> offers some of the same possibilities as GNU <b>parallel</b>.</p>

<p><b>xargs</b> deals badly with special characters (such as space, \, &#39; and &quot;). To see the problem try this:</p>

<pre><code>  touch important_file
  touch &#39;not important_file&#39;
  ls not* | xargs rm
  mkdir -p &quot;My brother&#39;s 12\&quot; records&quot;
  ls | xargs rmdir
  touch &#39;c:\windows\system32\clfs.sys&#39;
  echo &#39;c:\windows\system32\clfs.sys&#39; | xargs ls -l</code></pre>

<p>You can specify <b>-0</b>, but many input generators are not optimized for using <b>NUL</b> as separator but are optimized for <b>newline</b> as separator. E.g <b>head</b>, <b>tail</b>, <b>awk</b>, <b>ls</b>, <b>echo</b>, <b>sed</b>, <b>tar -v</b>, <b>perl</b> (<b>-0</b> and \0 instead of \n), <b>locate</b> (requires using <b>-0</b>), <b>find</b> (requires using <b>-print0</b>), <b>grep</b> (requires user to use <b>-z</b> or <b>-Z</b>), <b>sort</b> (requires using <b>-z</b>).</p>

<p>GNU <b>parallel</b>&#39;s newline separation can be emulated with:</p>

<p><b>cat | xargs -d &quot;\n&quot; -n1 <i>command</i></b></p>

<p><b>xargs</b> can run a given number of jobs in parallel, but has no support for running number-of-cpu-cores jobs in parallel.</p>

<p><b>xargs</b> has no support for grouping the output, therefore output may run together, e.g. the first half of a line is from one process and the last half of the line is from another process. The example <b>Parallel grep</b> cannot be done reliably with <b>xargs</b> because of this. To see this in action try:</p>

<pre><code>  parallel perl -e &#39;\$a=\&quot;1\&quot;.\&quot;{}\&quot;x10000000\;print\ \$a,\&quot;\\n\&quot;&#39; \
    &#39;&gt;&#39; {} ::: a b c d e f g h
  # Serial = no mixing = the wanted result
  # &#39;tr -s a-z&#39; squeezes repeating letters into a single letter
  echo a b c d e f g h | xargs -P1 -n1 grep 1 | tr -s a-z
  # Compare to 8 jobs in parallel
  parallel -kP8 -n1 grep 1 ::: a b c d e f g h | tr -s a-z
  echo a b c d e f g h | xargs -P8 -n1 grep 1 | tr -s a-z
  echo a b c d e f g h | xargs -P8 -n1 grep --line-buffered 1 | \
    tr -s a-z</code></pre>

<p>Or try this:</p>

<pre><code>  slow_seq() {
    echo Count to &quot;$@&quot;
    seq &quot;$@&quot; |
      perl -ne &#39;$|=1; for(split//){ print; select($a,$a,$a,0.100);}&#39;
  }
  export -f slow_seq
  # Serial = no mixing = the wanted result
  seq 8 | xargs -n1 -P1 -I {} bash -c &#39;slow_seq {}&#39;
  # Compare to 8 jobs in parallel
  seq 8 | parallel -P8 slow_seq {}
  seq 8 | xargs -n1 -P8 -I {} bash -c &#39;slow_seq {}&#39;</code></pre>

<p><b>xargs</b> has no support for keeping the order of the output, therefore if running jobs in parallel using <b>xargs</b> the output of the second job cannot be postponed till the first job is done.</p>

<p><b>xargs</b> has no support for running jobs on remote computers.</p>

<p><b>xargs</b> has no support for context replace, so you will have to create the arguments.</p>

<p>If you use a replace string in <b>xargs</b> (<b>-I</b>) you can not force <b>xargs</b> to use more than one argument.</p>

<p>Quoting in <b>xargs</b> works like <b>-q</b> in GNU <b>parallel</b>. This means composed commands and redirection require using <b>bash -c</b>.</p>

<pre><code>  ls | parallel &quot;wc {} &gt;{}.wc&quot;
  ls | parallel &quot;echo {}; ls {}|wc&quot;</code></pre>

<p>becomes (assuming you have 8 cores and that none of the file names contain space, &quot; or &#39;).</p>

<pre><code>  ls | xargs -d &quot;\n&quot; -P8 -I {} bash -c &quot;wc {} &gt;{}.wc&quot;
  ls | xargs -d &quot;\n&quot; -P8 -I {} bash -c &quot;echo {}; ls {}|wc&quot;</code></pre>

<p>https://www.gnu.org/software/findutils/</p>

<h2 id="DIFFERENCES-BETWEEN-find--exec-AND-GNU-Parallel">DIFFERENCES BETWEEN find -exec AND GNU Parallel</h2>

<p><b>find -exec</b> offer some of the same possibilities as GNU <b>parallel</b>.</p>

<p><b>find -exec</b> only works on files. So processing other input (such as hosts or URLs) will require creating these inputs as files. <b>find -exec</b> has no support for running commands in parallel.</p>

<p>https://www.gnu.org/software/findutils/</p>

<h2 id="DIFFERENCES-BETWEEN-make--j-AND-GNU-Parallel">DIFFERENCES BETWEEN make -j AND GNU Parallel</h2>

<p><b>make -j</b> can run jobs in parallel, but requires a crafted Makefile to do this. That results in extra quoting to get filename containing newline to work correctly.</p>

<p><b>make -j</b> computes a dependency graph before running jobs. Jobs run by GNU <b>parallel</b> does not depend on eachother.</p>

<p>(Very early versions of GNU <b>parallel</b> were coincidently implemented using <b>make -j</b>).</p>

<p>https://www.gnu.org/software/make/</p>

<h2 id="DIFFERENCES-BETWEEN-ppss-AND-GNU-Parallel">DIFFERENCES BETWEEN ppss AND GNU Parallel</h2>

<p><b>ppss</b> is also a tool for running jobs in parallel.</p>

<p>The output of <b>ppss</b> is status information and thus not useful for using as input for another command. The output from the jobs are put into files.</p>

<p>The argument replace string ($ITEM) cannot be changed. Arguments must be quoted - thus arguments containing special characters (space &#39;&quot;&amp;!*) may cause problems. More than one argument is not supported. File names containing newlines are not processed correctly. When reading input from a file null cannot be used as a terminator. <b>ppss</b> needs to read the whole input file before starting any jobs.</p>

<p>Output and status information is stored in ppss_dir and thus requires cleanup when completed. If the dir is not removed before running <b>ppss</b> again it may cause nothing to happen as <b>ppss</b> thinks the task is already done. GNU <b>parallel</b> will normally not need cleaning up if running locally and will only need cleaning up if stopped abnormally and running remote (<b>--cleanup</b> may not complete if stopped abnormally). The example <b>Parallel grep</b> would require extra postprocessing if written using <b>ppss</b>.</p>

<p>For remote systems PPSS requires 3 steps: config, deploy, and start. GNU <b>parallel</b> only requires one step.</p>

<h3 id="EXAMPLES-FROM-ppss-MANUAL">EXAMPLES FROM ppss MANUAL</h3>

<p>Here are the examples from <b>ppss</b>&#39;s manual page with the equivalent using GNU <b>parallel</b>:</p>

<p><b>1</b> ./ppss.sh standalone -d /path/to/files -c &#39;gzip &#39;</p>

<p><b>1</b> find /path/to/files -type f | parallel gzip</p>

<p><b>2</b> ./ppss.sh standalone -d /path/to/files -c &#39;cp &quot;$ITEM&quot; /destination/dir &#39;</p>

<p><b>2</b> find /path/to/files -type f | parallel cp {} /destination/dir</p>

<p><b>3</b> ./ppss.sh standalone -f list-of-urls.txt -c &#39;wget -q &#39;</p>

<p><b>3</b> parallel -a list-of-urls.txt wget -q</p>

<p><b>4</b> ./ppss.sh standalone -f list-of-urls.txt -c &#39;wget -q &quot;$ITEM&quot;&#39;</p>

<p><b>4</b> parallel -a list-of-urls.txt wget -q {}</p>

<p><b>5</b> ./ppss config -C config.cfg -c &#39;encode.sh &#39; -d /source/dir -m 192.168.1.100 -u ppss -k ppss-key.key -S ./encode.sh -n nodes.txt -o /some/output/dir --upload --download ; ./ppss deploy -C config.cfg ; ./ppss start -C config</p>

<p><b>5</b> # parallel does not use configs. If you want a different username put it in nodes.txt: user@hostname</p>

<p><b>5</b> find source/dir -type f | parallel --sshloginfile nodes.txt --trc {.}.mp3 lame -a {} -o {.}.mp3 --preset standard --quiet</p>

<p><b>6</b> ./ppss stop -C config.cfg</p>

<p><b>6</b> killall -TERM parallel</p>

<p><b>7</b> ./ppss pause -C config.cfg</p>

<p><b>7</b> Press: CTRL-Z or killall -SIGTSTP parallel</p>

<p><b>8</b> ./ppss continue -C config.cfg</p>

<p><b>8</b> Enter: fg or killall -SIGCONT parallel</p>

<p><b>9</b> ./ppss.sh status -C config.cfg</p>

<p><b>9</b> killall -SIGUSR2 parallel</p>

<p>https://github.com/louwrentius/PPSS</p>

<h2 id="DIFFERENCES-BETWEEN-pexec-AND-GNU-Parallel">DIFFERENCES BETWEEN pexec AND GNU Parallel</h2>

<p><b>pexec</b> is also a tool for running jobs in parallel.</p>

<h3 id="EXAMPLES-FROM-pexec-MANUAL">EXAMPLES FROM pexec MANUAL</h3>

<p>Here are the examples from <b>pexec</b>&#39;s info page with the equivalent using GNU <b>parallel</b>:</p>

<p><b>1</b> pexec -o sqrt-%s.dat -p &quot;$(seq 10)&quot; -e NUM -n 4 -c -- \ &#39;echo &quot;scale=10000;sqrt($NUM)&quot; | bc&#39;</p>

<p><b>1</b> seq 10 | parallel -j4 &#39;echo &quot;scale=10000;sqrt({})&quot; | bc &gt; sqrt-{}.dat&#39;</p>

<p><b>2</b> pexec -p &quot;$(ls myfiles*.ext)&quot; -i %s -o %s.sort -- sort</p>

<p><b>2</b> ls myfiles*.ext | parallel sort {} &quot;&gt;{}.sort&quot;</p>

<p><b>3</b> pexec -f image.list -n auto -e B -u star.log -c -- \ &#39;fistar $B.fits -f 100 -F id,x,y,flux -o $B.star&#39;</p>

<p><b>3</b> parallel -a image.list \ &#39;fistar {}.fits -f 100 -F id,x,y,flux -o {}.star&#39; 2&gt;star.log</p>

<p><b>4</b> pexec -r *.png -e IMG -c -o - -- \ &#39;convert $IMG ${IMG%.png}.jpeg ; &quot;echo $IMG: done&quot;&#39;</p>

<p><b>4</b> ls *.png | parallel &#39;convert {} {.}.jpeg; echo {}: done&#39;</p>

<p><b>5</b> pexec -r *.png -i %s -o %s.jpg -c &#39;pngtopnm | pnmtojpeg&#39;</p>

<p><b>5</b> ls *.png | parallel &#39;pngtopnm &lt; {} | pnmtojpeg &gt; {}.jpg&#39;</p>

<p><b>6</b> for p in *.png ; do echo ${p%.png} ; done | \ pexec -f - -i %s.png -o %s.jpg -c &#39;pngtopnm | pnmtojpeg&#39;</p>

<p><b>6</b> ls *.png | parallel &#39;pngtopnm &lt; {} | pnmtojpeg &gt; {.}.jpg&#39;</p>

<p><b>7</b> LIST=$(for p in *.png ; do echo ${p%.png} ; done) pexec -r $LIST -i %s.png -o %s.jpg -c &#39;pngtopnm | pnmtojpeg&#39;</p>

<p><b>7</b> ls *.png | parallel &#39;pngtopnm &lt; {} | pnmtojpeg &gt; {.}.jpg&#39;</p>

<p><b>8</b> pexec -n 8 -r *.jpg -y unix -e IMG -c \ &#39;pexec -j -m blockread -d $IMG | \ jpegtopnm | pnmscale 0.5 | pnmtojpeg | \ pexec -j -m blockwrite -s th_$IMG&#39;</p>

<p><b>8</b> Combining GNU <b>parallel</b> and GNU <b>sem</b>.</p>

<p><b>8</b> ls *jpg | parallel -j8 &#39;sem --id blockread cat {} | jpegtopnm |&#39; \ &#39;pnmscale 0.5 | pnmtojpeg | sem --id blockwrite cat &gt; th_{}&#39;</p>

<p><b>8</b> If reading and writing is done to the same disk, this may be faster as only one process will be either reading or writing:</p>

<p><b>8</b> ls *jpg | parallel -j8 &#39;sem --id diskio cat {} | jpegtopnm |&#39; \ &#39;pnmscale 0.5 | pnmtojpeg | sem --id diskio cat &gt; th_{}&#39;</p>

<p>https://www.gnu.org/software/pexec/</p>

<h2 id="DIFFERENCES-BETWEEN-xjobs-AND-GNU-Parallel">DIFFERENCES BETWEEN xjobs AND GNU Parallel</h2>

<p><b>xjobs</b> is also a tool for running jobs in parallel. It only supports running jobs on your local computer.</p>

<p><b>xjobs</b> deals badly with special characters just like <b>xargs</b>. See the section <b>DIFFERENCES BETWEEN xargs AND GNU Parallel</b>.</p>

<p>Here are the examples from <b>xjobs</b>&#39;s man page with the equivalent using GNU <b>parallel</b>:</p>

<p><b>1</b> ls -1 *.zip | xjobs unzip</p>

<p><b>1</b> ls *.zip | parallel unzip</p>

<p><b>2</b> ls -1 *.zip | xjobs -n unzip</p>

<p><b>2</b> ls *.zip | parallel unzip &gt;/dev/null</p>

<p><b>3</b> find . -name &#39;*.bak&#39; | xjobs gzip</p>

<p><b>3</b> find . -name &#39;*.bak&#39; | parallel gzip</p>

<p><b>4</b> ls -1 *.jar | sed &#39;s/\(.*\)/\1 &gt; \1.idx/&#39; | xjobs jar tf</p>

<p><b>4</b> ls *.jar | parallel jar tf {} &#39;&gt;&#39; {}.idx</p>

<p><b>5</b> xjobs -s script</p>

<p><b>5</b> cat script | parallel</p>

<p><b>6</b> mkfifo /var/run/my_named_pipe; xjobs -s /var/run/my_named_pipe &amp; echo unzip 1.zip &gt;&gt; /var/run/my_named_pipe; echo tar cf /backup/myhome.tar /home/me &gt;&gt; /var/run/my_named_pipe</p>

<p><b>6</b> mkfifo /var/run/my_named_pipe; cat /var/run/my_named_pipe | parallel &amp; echo unzip 1.zip &gt;&gt; /var/run/my_named_pipe; echo tar cf /backup/myhome.tar /home/me &gt;&gt; /var/run/my_named_pipe</p>

<p>http://www.maier-komor.de/xjobs.html</p>

<h2 id="DIFFERENCES-BETWEEN-prll-AND-GNU-Parallel">DIFFERENCES BETWEEN prll AND GNU Parallel</h2>

<p><b>prll</b> is also a tool for running jobs in parallel. It does not support running jobs on remote computers.</p>

<p><b>prll</b> encourages using BASH aliases and BASH functions instead of scripts. GNU <b>parallel</b> supports scripts directly, functions if they are exported using <b>export -f</b>, and aliases if using <b>env_parallel</b>.</p>

<p><b>prll</b> generates a lot of status information on stderr (standard error) which makes it harder to use the stderr (standard error) output of the job directly as input for another program.</p>

<p>Here is the example from <b>prll</b>&#39;s man page with the equivalent using GNU <b>parallel</b>:</p>

<pre><code>  prll -s &#39;mogrify -flip $1&#39; *.jpg
  parallel mogrify -flip ::: *.jpg</code></pre>

<p>https://github.com/exzombie/prll</p>

<h2 id="DIFFERENCES-BETWEEN-dxargs-AND-GNU-Parallel">DIFFERENCES BETWEEN dxargs AND GNU Parallel</h2>

<p><b>dxargs</b> is also a tool for running jobs in parallel.</p>

<p><b>dxargs</b> does not deal well with more simultaneous jobs than SSHD&#39;s MaxStartups. <b>dxargs</b> is only built for remote run jobs, but does not support transferring of files.</p>

<p>http://www.semicomplete.com/blog/geekery/distributed-xargs.html</p>

<h2 id="DIFFERENCES-BETWEEN-mdm-middleman-AND-GNU-Parallel">DIFFERENCES BETWEEN mdm/middleman AND GNU Parallel</h2>

<p>middleman(mdm) is also a tool for running jobs in parallel.</p>

<p>Here are the shellscripts of http://mdm.berlios.de/usage.html ported to GNU <b>parallel</b>:</p>

<pre><code>  seq 19 | parallel buffon -o - | sort -n &gt; result
  cat files | parallel cmd
  find dir -execdir sem cmd {} \;</code></pre>

<p>https://github.com/cklin/mdm</p>

<h2 id="DIFFERENCES-BETWEEN-xapply-AND-GNU-Parallel">DIFFERENCES BETWEEN xapply AND GNU Parallel</h2>

<p><b>xapply</b> can run jobs in parallel on the local computer.</p>

<p>Here are the examples from <b>xapply</b>&#39;s man page with the equivalent using GNU <b>parallel</b>:</p>

<p><b>1</b> xapply &#39;(cd %1 &amp;&amp; make all)&#39; */</p>

<p><b>1</b> parallel &#39;cd {} &amp;&amp; make all&#39; ::: */</p>

<p><b>2</b> xapply -f &#39;diff %1 ../version5/%1&#39; manifest | more</p>

<p><b>2</b> parallel diff {} ../version5/{} &lt; manifest | more</p>

<p><b>3</b> xapply -p/dev/null -f &#39;diff %1 %2&#39; manifest1 checklist1</p>

<p><b>3</b> parallel --link diff {1} {2} :::: manifest1 checklist1</p>

<p><b>4</b> xapply &#39;indent&#39; *.c</p>

<p><b>4</b> parallel indent ::: *.c</p>

<p><b>5</b> find ~ksb/bin -type f ! -perm -111 -print | xapply -f -v &#39;chmod a+x&#39; -</p>

<p><b>5</b> find ~ksb/bin -type f ! -perm -111 -print | parallel -v chmod a+x</p>

<p><b>6</b> find */ -... | fmt 960 1024 | xapply -f -i /dev/tty &#39;vi&#39; -</p>

<p><b>6</b> sh &lt;(find */ -... | parallel -s 1024 echo vi)</p>

<p><b>6</b> find */ -... | parallel -s 1024 -Xuj1 vi</p>

<p><b>7</b> find ... | xapply -f -5 -i /dev/tty &#39;vi&#39; - - - - -</p>

<p><b>7</b> sh &lt;(find ... |parallel -n5 echo vi)</p>

<p><b>7</b> find ... |parallel -n5 -uj1 vi</p>

<p><b>8</b> xapply -fn &quot;&quot; /etc/passwd</p>

<p><b>8</b> parallel -k echo &lt; /etc/passwd</p>

<p><b>9</b> tr &#39;:&#39; &#39;\012&#39; &lt; /etc/passwd | xapply -7 -nf &#39;chown %1 %6&#39; - - - - - - -</p>

<p><b>9</b> tr &#39;:&#39; &#39;\012&#39; &lt; /etc/passwd | parallel -N7 chown {1} {6}</p>

<p><b>10</b> xapply &#39;[ -d %1/RCS ] || echo %1&#39; */</p>

<p><b>10</b> parallel &#39;[ -d {}/RCS ] || echo {}&#39; ::: */</p>

<p><b>11</b> xapply -f &#39;[ -f %1 ] &amp;&amp; echo %1&#39; List | ...</p>

<p><b>11</b> parallel &#39;[ -f {} ] &amp;&amp; echo {}&#39; &lt; List | ...</p>

<p>http://carrera.databits.net/~ksb/msrc/local/bin/xapply/xapply.html</p>

<h2 id="DIFFERENCES-BETWEEN-AIX-apply-AND-GNU-Parallel">DIFFERENCES BETWEEN AIX apply AND GNU Parallel</h2>

<p><b>apply</b> can build command lines based on a template and arguments - very much like GNU <b>parallel</b>. <b>apply</b> does not run jobs in parallel. <b>apply</b> does not use an argument separator (like <b>:::</b>); instead the template must be the first argument.</p>

<p>Here are the examples from https://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.cmds1/apply.htm</p>

<p>1. To obtain results similar to those of the <b>ls</b> command, enter:</p>

<pre><code>  apply echo *
  parallel echo ::: *</code></pre>

<p>2. To compare the file named <b>a1</b> to the file named <b>b1</b>, and the file named <b>a2</b> to the file named <b>b2</b>, enter:</p>

<pre><code>  apply -2 cmp a1 b1 a2 b2
  parallel -N2 cmp ::: a1 b1 a2 b2</code></pre>

<p>3. To run the <b>who</b> command five times, enter:</p>

<pre><code>  apply -0 who 1 2 3 4 5
  parallel -N0 who ::: 1 2 3 4 5</code></pre>

<p>4. To link all files in the current directory to the directory <b>/usr/joe</b>, enter:</p>

<pre><code>  apply &#39;ln %1 /usr/joe&#39; *
  parallel ln {} /usr/joe ::: *</code></pre>

<p>https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.cmds1/apply.htm</p>

<h2 id="DIFFERENCES-BETWEEN-paexec-AND-GNU-Parallel">DIFFERENCES BETWEEN paexec AND GNU Parallel</h2>

<p><b>paexec</b> can run jobs in parallel on both the local and remote computers.</p>

<p><b>paexec</b> requires commands to print a blank line as the last output. This means you will have to write a wrapper for most programs.</p>

<p><b>paexec</b> has a job dependency facility so a job can depend on another job to be executed successfully. Sort of a poor-man&#39;s <b>make</b>.</p>

<p>Here are the examples from <b>paexec</b>&#39;s example catalog with the equivalent using GNU <b>parallel</b>:</p>

<dl>

<dt id="div_X_run">1_div_X_run:</dt>
<dd>

<pre><code>  ../../paexec -s -l -c &quot;`pwd`/1_div_X_cmd&quot; -n +1 &lt;&lt;EOF [...]
  parallel echo {} &#39;|&#39; `pwd`/1_div_X_cmd &lt;&lt;EOF [...]</code></pre>

</dd>
<dt id="all_substr_run">all_substr_run:</dt>
<dd>

<pre><code>  ../../paexec -lp -c &quot;`pwd`/all_substr_cmd&quot; -n +3 &lt;&lt;EOF [...]
  parallel echo {} &#39;|&#39; `pwd`/all_substr_cmd &lt;&lt;EOF [...]</code></pre>

</dd>
<dt id="cc_wrapper_run">cc_wrapper_run:</dt>
<dd>

<pre><code>  ../../paexec -c &quot;env CC=gcc CFLAGS=-O2 `pwd`/cc_wrapper_cmd&quot; \
             -n &#39;host1 host2&#39; \
             -t &#39;/usr/bin/ssh -x&#39; &lt;&lt;EOF [...]
  parallel echo {} &#39;|&#39; &quot;env CC=gcc CFLAGS=-O2 `pwd`/cc_wrapper_cmd&quot; \
             -S host1,host2 &lt;&lt;EOF [...]
  # This is not exactly the same, but avoids the wrapper
  parallel gcc -O2 -c -o {.}.o {} \
             -S host1,host2 &lt;&lt;EOF [...]</code></pre>

</dd>
<dt id="toupper_run">toupper_run:</dt>
<dd>

<pre><code>  ../../paexec -lp -c &quot;`pwd`/toupper_cmd&quot; -n +10 &lt;&lt;EOF [...]
  parallel echo {} &#39;|&#39; ./toupper_cmd &lt;&lt;EOF [...]
  # Without the wrapper:
  parallel echo {} &#39;| awk {print\ toupper\(\$0\)}&#39; &lt;&lt;EOF [...]</code></pre>

</dd>
</dl>

<p>https://github.com/cheusov/paexec</p>

<h2 id="DIFFERENCES-BETWEEN-map-sitaramc-AND-GNU-Parallel">DIFFERENCES BETWEEN map(sitaramc) AND GNU Parallel</h2>

<p><b>map</b> sees it as a feature to have less features and in doing so it also handles corner cases incorrectly. A lot of GNU <b>parallel</b>&#39;s code is to handle corner cases correctly on every platform, so you will not get a nasty surprise if a user for example saves a file called: <i>My brother&#39;s 12&quot; records.txt</i></p>

<p><b>map</b>&#39;s example showing how to deal with special characters fails on special characters:</p>

<pre><code>  echo &quot;The Cure&quot; &gt; My\ brother\&#39;s\ 12\&quot;\ records

  ls | \
    map &#39;echo -n `gzip &lt; &quot;%&quot; | wc -c`; echo -n &#39;*100/&#39;; wc -c &lt; &quot;%&quot;&#39; | bc</code></pre>

<p>It works with GNU <b>parallel</b>:</p>

<pre><code>  ls | \
    parallel &#39;echo -n `gzip &lt; {} | wc -c`; echo -n &#39;*100/&#39;; wc -c &lt; {}&#39; | bc</code></pre>

<p>And you can even get the file name prepended:</p>

<pre><code>  ls | \
    parallel --tag &#39;(echo -n `gzip &lt; {} | wc -c`&#39;*100/&#39;; wc -c &lt; {}) | bc&#39;</code></pre>

<p><b>map</b> has no support for grouping. So this gives the wrong results without any warnings:</p>

<pre><code>  parallel perl -e &#39;\$a=\&quot;1{}\&quot;x10000000\;print\ \$a,\&quot;\\n\&quot;&#39; &#39;&gt;&#39; {} \
    ::: a b c d e f
  ls -l a b c d e f
  parallel -kP4 -n1 grep 1 &gt; out.par ::: a b c d e f
  map -p 4 &#39;grep 1&#39; a b c d e f &gt; out.map-unbuf
  map -p 4 &#39;grep --line-buffered 1&#39; a b c d e f &gt; out.map-linebuf
  map -p 1 &#39;grep --line-buffered 1&#39; a b c d e f &gt; out.map-serial
  ls -l out*
  md5sum out*</code></pre>

<p>The documentation shows a workaround, but not only does that mix stdout (standard output) with stderr (standard error) it also fails completely for certain jobs (and may even be considered less readable):</p>

<pre><code>  parallel echo -n {} ::: 1 2 3

  map -p 4 &#39;echo -n % 2&gt;&amp;1 | sed -e &quot;s/^/$$:/&quot;&#39; 1 2 3 | sort | cut -f2- -d:</code></pre>

<p><b>map</b>s replacement strings (% %D %B %E) can be simulated in GNU <b>parallel</b> by putting this in <b>~/.parallel/config</b>:</p>

<pre><code>  --rpl &#39;%&#39;
  --rpl &#39;%D $_=::shell_quote(::dirname($_));&#39;
  --rpl &#39;%B s:.*/::;s:\.[^/.]+$::;&#39;
  --rpl &#39;%E s:.*\.::&#39;</code></pre>

<p><b>map</b> cannot handle bundled options: <b>map -vp 0 echo this fails</b></p>

<p><b>map</b> does not have an argument separator on the command line, but uses the first argument as command. This makes quoting harder which again may affect readability. Compare:</p>

<pre><code>  map -p 2 perl\\\ -ne\\\ \\\&#39;/^\\\\S+\\\\s+\\\\S+\\\$/\\\ and\\\ print\\\ \\\$ARGV,\\\&quot;\\\\n\\\&quot;\\\&#39; *

  parallel -q perl -ne &#39;/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;&#39; ::: *</code></pre>

<p><b>map</b> can do multiple arguments with context replace, but not without context replace:</p>

<pre><code>  parallel --xargs echo &#39;BEGIN{&#39;{}&#39;}END&#39; ::: 1 2 3</code></pre>

<p><b>map</b> does not set exit value according to whether one of the jobs failed:</p>

<pre><code>  parallel false ::: 1 || echo Job failed

  map false 1 || echo Never run</code></pre>

<p><b>map</b> requires Perl v5.10.0 making it harder to use on old systems.</p>

<p><b>map</b> has no way of using % in the command (GNU Parallel has -I to specify another replacement string than <b>{}</b>).</p>

<p>By design <b>map</b> is option incompatible with <b>xargs</b>, it does not have remote job execution, a structured way of saving results, multiple input sources, progress indicator, configurable record delimiter (only field delimiter), logging of jobs run with possibility to resume, keeping the output in the same order as input, --pipe processing, and dynamically timeouts.</p>

<p>https://github.com/sitaramc/map</p>

<h2 id="DIFFERENCES-BETWEEN-ladon-AND-GNU-Parallel">DIFFERENCES BETWEEN ladon AND GNU Parallel</h2>

<p><b>ladon</b> can run multiple jobs on files in parallel.</p>

<p><b>ladon</b> only works on files and the only way to specify files is using a quoted glob string (such as \*.jpg). It is not possible to list the files manually.</p>

<p>As replacement strings it uses FULLPATH DIRNAME BASENAME EXT RELDIR RELPATH</p>

<p>These can be simulated using GNU <b>parallel</b> by putting this in <b>~/.parallel/config</b>:</p>

<pre><code>    --rpl &#39;FULLPATH $_=::shell_quote($_);chomp($_=qx{readlink -f $_});&#39;
    --rpl &#39;DIRNAME $_=::shell_quote(::dirname($_));chomp($_=qx{readlink -f $_});&#39;
    --rpl &#39;BASENAME s:.*/::;s:\.[^/.]+$::;&#39;
    --rpl &#39;EXT s:.*\.::&#39;
    --rpl &#39;RELDIR $_=::shell_quote($_);chomp(($_,$c)=qx{readlink -f $_;pwd});s:\Q$c/\E::;$_=::dirname($_);&#39;
    --rpl &#39;RELPATH $_=::shell_quote($_);chomp(($_,$c)=qx{readlink -f $_;pwd});s:\Q$c/\E::;&#39;</code></pre>

<p><b>ladon</b> deals badly with filenames containing &quot; and newline, and it fails for output larger than 200k:</p>

<pre><code>    ladon &#39;*&#39; -- seq 36000 | wc</code></pre>

<h3 id="EXAMPLES-FROM-ladon-MANUAL">EXAMPLES FROM ladon MANUAL</h3>

<p>It is assumed that the &#39;--rpl&#39;s above are put in <b>~/.parallel/config</b> and that it is run under a shell that supports &#39;**&#39; globbing (such as <b>zsh</b>):</p>

<p><b>1</b> ladon &quot;**/*.txt&quot; -- echo RELPATH</p>

<p><b>1</b> parallel echo RELPATH ::: **/*.txt</p>

<p><b>2</b> ladon &quot;~/Documents/**/*.pdf&quot; -- shasum FULLPATH &gt;hashes.txt</p>

<p><b>2</b> parallel shasum FULLPATH ::: ~/Documents/**/*.pdf &gt;hashes.txt</p>

<p><b>3</b> ladon -m thumbs/RELDIR &quot;**/*.jpg&quot; -- convert FULLPATH -thumbnail 100x100^ -gravity center -extent 100x100 thumbs/RELPATH</p>

<p><b>3</b> parallel mkdir -p thumbs/RELDIR\; convert FULLPATH -thumbnail 100x100^ -gravity center -extent 100x100 thumbs/RELPATH ::: **/*.jpg</p>

<p><b>4</b> ladon &quot;~/Music/*.wav&quot; -- lame -V 2 FULLPATH DIRNAME/BASENAME.mp3</p>

<p><b>4</b> parallel lame -V 2 FULLPATH DIRNAME/BASENAME.mp3 ::: ~/Music/*.wav</p>

<p>https://github.com/danielgtaylor/ladon</p>

<h2 id="DIFFERENCES-BETWEEN-jobflow-AND-GNU-Parallel">DIFFERENCES BETWEEN jobflow AND GNU Parallel</h2>

<p><b>jobflow</b> can run multiple jobs in parallel.</p>

<p>Just like <b>xargs</b> output from <b>jobflow</b> jobs running in parallel mix together by default. <b>jobflow</b> can buffer into files (placed in /run/shm), but these are not cleaned up - not even if <b>jobflow</b> dies unexpectently. If the total output is big (in the order of RAM+swap) it can cause the system to run out of memory.</p>

<p><b>jobflow</b> gives no error if the command is unknown, and like <b>xargs</b> redirection requires wrapping with <b>bash -c</b>.</p>

<p><b>jobflow</b> makes it possible to set resource limits on the running jobs. This can be emulated by GNU <b>parallel</b> using <b>bash</b>&#39;s <b>ulimit</b>:</p>

<pre><code>  jobflow -limits=mem=100M,cpu=3,fsize=20M,nofiles=300 myjob

  parallel &#39;ulimit -v 102400 -t 3 -f 204800 -n 300 myjob&#39;</code></pre>

<h3 id="EXAMPLES-FROM-jobflow-README">EXAMPLES FROM jobflow README</h3>

<p><b>1</b> cat things.list | jobflow -threads=8 -exec ./mytask {}</p>

<p><b>1</b> cat things.list | parallel -j8 ./mytask {}</p>

<p><b>2</b> seq 100 | jobflow -threads=100 -exec echo {}</p>

<p><b>2</b> seq 100 | parallel -j100 echo {}</p>

<p><b>3</b> cat urls.txt | jobflow -threads=32 -exec wget {}</p>

<p><b>3</b> cat urls.txt | parallel -j32 wget {}</p>

<p><b>4</b> find . -name &#39;*.bmp&#39; | jobflow -threads=8 -exec bmp2jpeg {.}.bmp {.}.jpg</p>

<p><b>4</b> find . -name &#39;*.bmp&#39; | parallel -j8 bmp2jpeg {.}.bmp {.}.jpg</p>

<p>https://github.com/rofl0r/jobflow</p>

<h2 id="DIFFERENCES-BETWEEN-gargs-AND-GNU-Parallel">DIFFERENCES BETWEEN gargs AND GNU Parallel</h2>

<p><b>gargs</b> can run multiple jobs in parallel.</p>

<p>Older versions cache output in memory. This causes it to be extremely slow when the output is larger than the physical RAM, and can cause the system to run out of memory.</p>

<p>See more details on this in <b>man parallel_design</b>.</p>

<p>Newer versions cache output in files, but leave files in $TMPDIR if it is killed.</p>

<p>Output to stderr (standard error) is changed if the command fails.</p>

<p>Here are the two examples from <b>gargs</b> website.</p>

<p><b>1</b> seq 12 -1 1 | gargs -p 4 -n 3 &quot;sleep {0}; echo {1} {2}&quot;</p>

<p><b>1</b> seq 12 -1 1 | parallel -P 4 -n 3 &quot;sleep {1}; echo {2} {3}&quot;</p>

<p><b>2</b> cat t.txt | gargs --sep &quot;\s+&quot; -p 2 &quot;echo &#39;{0}:{1}-{2}&#39; full-line: \&#39;{}\&#39;&quot;</p>

<p><b>2</b> cat t.txt | parallel --colsep &quot;\\s+&quot; -P 2 &quot;echo &#39;{1}:{2}-{3}&#39; full-line: \&#39;{}\&#39;&quot;</p>

<p>https://github.com/brentp/gargs</p>

<h2 id="DIFFERENCES-BETWEEN-orgalorg-AND-GNU-Parallel">DIFFERENCES BETWEEN orgalorg AND GNU Parallel</h2>

<p><b>orgalorg</b> can run the same job on multiple machines. This is related to <b>--onall</b> and <b>--nonall</b>.</p>

<p><b>orgalorg</b> supports entering the SSH password - provided it is the same for all servers. GNU <b>parallel</b> advocates using <b>ssh-agent</b> instead, but it is possible to emulate <b>orgalorg</b>&#39;s behavior by setting SSHPASS and by using <b>--ssh &quot;sshpass ssh&quot;</b>.</p>

<p>To make the emulation easier, make a simple alias:</p>

<pre><code>  alias par_emul=&quot;parallel -j0 --ssh &#39;sshpass ssh&#39; --nonall --tag --linebuffer&quot;</code></pre>

<p>If you want to supply a password run:</p>

<pre><code>  SSHPASS=`ssh-askpass`</code></pre>

<p>or set the password directly:</p>

<pre><code>  SSHPASS=P4$$w0rd!</code></pre>

<p>If the above is set up you can then do:</p>

<pre><code>  orgalorg -o frontend1 -o frontend2 -p -C uptime
  par_emul -S frontend1 -S frontend2 uptime

  orgalorg -o frontend1 -o frontend2 -p -C top -bid 1
  par_emul -S frontend1 -S frontend2 top -bid 1

  orgalorg -o frontend1 -o frontend2 -p -er /tmp -n &#39;md5sum /tmp/bigfile&#39; -S bigfile
  par_emul -S frontend1 -S frontend2 --basefile bigfile --workdir /tmp  md5sum /tmp/bigfile</code></pre>

<p><b>orgalorg</b> has a progress indicator for the transferring of a file. GNU <b>parallel</b> does not.</p>

<p>https://github.com/reconquest/orgalorg</p>

<h2 id="DIFFERENCES-BETWEEN-Rust-parallel-AND-GNU-Parallel">DIFFERENCES BETWEEN Rust parallel AND GNU Parallel</h2>

<p>Rust parallel focuses on speed. It is almost as fast as <b>xargs</b>. It implements a few features from GNU <b>parallel</b>, but lacks many functions. All these fail:</p>

<pre><code>  # Show what would be executed
  parallel --dry-run echo ::: a
  # Read arguments from file
  parallel -a file echo
  # Changing the delimiter
  parallel -d _ echo ::: a_b_c_</code></pre>

<p>These do something different from GNU <b>parallel</b></p>

<pre><code>  # Read more arguments at a time -n
  parallel -n 2 echo ::: 1 a 2 b
  # -q to protect quoted $ and space
  parallel -q perl -e &#39;$a=shift; print &quot;$a&quot;x10000000&#39; ::: a b c
  # Generation of combination of inputs
  parallel echo {1} {2} ::: red green blue ::: S M L XL XXL
  # {= perl expression =} replacement string
  parallel echo &#39;{= s/new/old/ =}&#39; ::: my.new your.new
  # --pipe
  seq 100000 | parallel --pipe wc
  # linked arguments
  parallel echo ::: S M L :::+ small medium large ::: R G B :::+ red green blue
  # Run different shell dialects
  zsh -c &#39;parallel echo \={} ::: zsh &amp;&amp; true&#39;
  csh -c &#39;parallel echo \$\{\} ::: shell &amp;&amp; true&#39;
  bash -c &#39;parallel echo \$\({}\) ::: pwd &amp;&amp; true&#39;
  # Rust parallel does not start before the last argument is read
  (seq 10; sleep 5; echo 2) | time parallel -j2 &#39;sleep 2; echo&#39;
  tail -f /var/log/syslog | parallel echo</code></pre>

<p>Rust parallel has no remote facilities.</p>

<p>It uses /tmp/parallel for tmp files and does not clean up if terminated abrubtly. If another user on the system uses Rust parallel, then /tmp/parallel will have the wrong permissions and Rust parallel will fail. A malicious user can setup the right permissions and symlink the output file to one of the user&#39;s files and next time the user uses Rust parallel it will overwrite this file.</p>

<p>If /tmp/parallel runs full during the run, Rust parallel does not report this, but finishes with success - thereby risking data loss.</p>

<p>https://github.com/mmstick/parallel</p>

<h2 id="DIFFERENCES-BETWEEN-Rush-AND-GNU-Parallel">DIFFERENCES BETWEEN Rush AND GNU Parallel</h2>

<p><b>rush</b> (https://github.com/shenwei356/rush) is written in Go and based on <b>gargs</b>.</p>

<p>Just like GNU <b>parallel</b> <b>rush</b> buffers in temporary files. But opposite GNU <b>parallel</b> <b>rush</b> does not clean up, if the process dies abnormally.</p>

<p><b>rush</b> has some string manipulations that can be emulated by putting this into ~/.parallel/config (/ is used instead of %, and % is used instead of ^ as that is closer to bash&#39;s ${var%postfix}):</p>

<pre><code>  --rpl &#39;{:} s:(\.[^/]+)*$::&#39;
  --rpl &#39;{:%([^}]+?)} s:$$1(\.[^/]+)*$::&#39;
  --rpl &#39;{/:%([^}]*?)} s:.*/(.*)$$1(\.[^/]+)*$:$1:&#39;
  --rpl &#39;{/:} s:(.*/)?([^/.]+)(\.[^/]+)*$:$2:&#39;
  --rpl &#39;{@(.*?)} /$$1/ and $_=$1;&#39;</code></pre>

<p>Here are the examples from <b>rush</b>&#39;s website with the equivalent command in GNU <b>parallel</b>.</p>

<h3 id="EXAMPLES">EXAMPLES</h3>

<p><b>1. Simple run, quoting is not necessary</b></p>

<pre><code>  $ seq 1 3 | rush echo {}

  $ seq 1 3 | parallel echo {}</code></pre>

<p><b>2. Read data from file (`-i`)</b></p>

<pre><code>  $ rush echo {} -i data1.txt -i data2.txt

  $ cat data1.txt data2.txt | parallel echo {}</code></pre>

<p><b>3. Keep output order (`-k`)</b></p>

<pre><code>  $ seq 1 3 | rush &#39;echo {}&#39; -k

  $ seq 1 3 | parallel -k echo {}</code></pre>

<p><b>4. Timeout (`-t`)</b></p>

<pre><code>  $ time seq 1 | rush &#39;sleep 2; echo {}&#39; -t 1

  $ time seq 1 | parallel --timeout 1 &#39;sleep 2; echo {}&#39;</code></pre>

<p><b>5. Retry (`-r`)</b></p>

<pre><code>  $ seq 1 | rush &#39;python unexisted_script.py&#39; -r 1

  $ seq 1 | parallel --retries 2 &#39;python unexisted_script.py&#39;</code></pre>

<p>Use <b>-u</b> to see it is really run twice:</p>

<pre><code>  $ seq 1 | parallel -u --retries 2 &#39;python unexisted_script.py&#39;</code></pre>

<p><b>6. Dirname (`{/}`) and basename (`{%}`) and remove custom suffix (`{^suffix}`)</b></p>

<pre><code>  $ echo dir/file_1.txt.gz | rush &#39;echo {/} {%} {^_1.txt.gz}&#39;

  $ echo dir/file_1.txt.gz |
      parallel --plus echo {//} {/} {%_1.txt.gz}</code></pre>

<p><b>7. Get basename, and remove last (`{.}`) or any (`{:}`) extension</b></p>

<pre><code>  $ echo dir.d/file.txt.gz | rush &#39;echo {.} {:} {%.} {%:}&#39;

  $ echo dir.d/file.txt.gz | parallel &#39;echo {.} {:} {/.} {/:}&#39;</code></pre>

<p><b>8. Job ID, combine fields index and other replacement strings</b></p>

<pre><code>  $ echo 12 file.txt dir/s_1.fq.gz |
      rush &#39;echo job {#}: {2} {2.} {3%:^_1}&#39;

  $ echo 12 file.txt dir/s_1.fq.gz |
      parallel --colsep &#39; &#39; &#39;echo job {#}: {2} {2.} {3/:%_1}&#39;</code></pre>

<p><b>9. Capture submatch using regular expression (`{@regexp}`)</b></p>

<pre><code>  $ echo read_1.fq.gz | rush &#39;echo {@(.+)_\d}&#39;

  $ echo read_1.fq.gz | parallel &#39;echo {@(.+)_\d}&#39;</code></pre>

<p><b>10. Custom field delimiter (`-d`)</b></p>

<pre><code>  $ echo a=b=c | rush &#39;echo {1} {2} {3}&#39; -d =

  $ echo a=b=c | parallel -d = echo {1} {2} {3}</code></pre>

<p><b>11. Send multi-lines to every command (`-n`)</b></p>

<pre><code>  $ seq 5 | rush -n 2 -k &#39;echo &quot;{}&quot;; echo&#39;

  $ seq 5 |
      parallel -n 2 -k \
        &#39;echo {=-1 $_=join&quot;\n&quot;,@arg[1..$#arg] =}; echo&#39;

  $ seq 5 | rush -n 2 -k &#39;echo &quot;{}&quot;; echo&#39; -J &#39; &#39;

  $ seq 5 | parallel -n 2 -k &#39;echo {}; echo&#39;</code></pre>

<p><b>12. Custom record delimiter (`-D`), note that empty records are not used.</b></p>

<pre><code>  $ echo a b c d | rush -D &quot; &quot; -k &#39;echo {}&#39;

  $ echo a b c d | parallel -d &quot; &quot; -k &#39;echo {}&#39;

  $ echo abcd | rush -D &quot;&quot; -k &#39;echo {}&#39;

  Cannot be done by GNU Parallel

  $ cat fasta.fa
  &gt;seq1
  tag
  &gt;seq2
  cat
  gat
  &gt;seq3
  attac
  a
  cat

  $ cat fasta.fa | rush -D &quot;&gt;&quot; \
      &#39;echo FASTA record {#}: name: {1} sequence: {2}&#39; -k -d &quot;\n&quot;
  # rush fails to join the multiline sequences

  $ cat fasta.fa | (read -n1 ignore_first_char;
      parallel -d &#39;&gt;&#39; --colsep &#39;\n&#39; echo FASTA record {#}: \
        name: {1} sequence: &#39;{=2 $_=join&quot;&quot;,@arg[2..$#arg]=}&#39;
    )</code></pre>

<p><b>13. Assign value to variable, like `awk -v` (`-v`)</b></p>

<pre><code>  $ seq 1 |
      rush &#39;echo Hello, {fname} {lname}!&#39; -v fname=Wei -v lname=Shen

  $ seq 1 |
      parallel -N0 \
        &#39;fname=Wei; lname=Shen; echo Hello, ${fname} ${lname}!&#39;

  $ for var in a b; do \
  $   seq 1 3 | rush -k -v var=$var &#39;echo var: {var}, data: {}&#39;; \
  $ done</code></pre>

<p>In GNU <b>parallel</b> you would typically do:</p>

<pre><code>  $ seq 1 3 | parallel -k echo var: {1}, data: {2} ::: a b :::: -</code></pre>

<p>If you <i>really</i> want the var:</p>

<pre><code>  $ seq 1 3 |
      parallel -k var={1} &#39;;echo var: $var, data: {}&#39; ::: a b :::: -</code></pre>

<p>If you <i>really</i> want the <b>for</b>-loop:</p>

<pre><code>  $ for var in a b; do
  &gt;   export var;
  &gt;   seq 1 3 | parallel -k &#39;echo var: $var, data: {}&#39;;
  &gt; done</code></pre>

<p>Contrary to <b>rush</b> this also works if the value is complex like:</p>

<pre><code>  My brother&#39;s 12&quot; records</code></pre>

<p><b>14. <b>Preset variable</b> (`-v`), avoid repeatedly writing verbose replacement strings</b></p>

<pre><code>  # naive way
  $ echo read_1.fq.gz | rush &#39;echo {:^_1} {:^_1}_2.fq.gz&#39;

  $ echo read_1.fq.gz | parallel &#39;echo {:%_1} {:%_1}_2.fq.gz&#39;

  # macro + removing suffix
  $ echo read_1.fq.gz |
      rush -v p=&#39;{:^_1}&#39; &#39;echo {p} {p}_2.fq.gz&#39;

  $ echo read_1.fq.gz |
      parallel &#39;p={:%_1}; echo $p ${p}_2.fq.gz&#39;

  # macro + regular expression
  $ echo read_1.fq.gz | rush -v p=&#39;{@(.+?)_\d}&#39; &#39;echo {p} {p}_2.fq.gz&#39;

  $ echo read_1.fq.gz | parallel &#39;p={@(.+?)_\d}; echo $p ${p}_2.fq.gz&#39;</code></pre>

<p>Contrary to <b>rush</b> GNU <b>parallel</b> works with complex values:</p>

<pre><code>  echo &quot;My brother&#39;s 12\&quot;read_1.fq.gz&quot; |
    parallel &#39;p={@(.+?)_\d}; echo $p ${p}_2.fq.gz&#39;</code></pre>

<p><b>15. Interrupt jobs by `Ctrl-C`, rush will stop unfinished commands and exit.</b></p>

<pre><code>  $ seq 1 20 | rush &#39;sleep 1; echo {}&#39;
  ^C

  $ seq 1 20 | parallel &#39;sleep 1; echo {}&#39;
  ^C</code></pre>

<p><b>16. Continue/resume jobs (`-c`). When some jobs failed (by execution failure, timeout, or cancelling by user with `Ctrl + C`), please switch flag `-c/--continue` on and run again, so that `rush` can save successful commands and ignore them in <i>NEXT</i> run.</b></p>

<pre><code>  $ seq 1 3 | rush &#39;sleep {}; echo {}&#39; -t 3 -c
  $ cat successful_cmds.rush
  $ seq 1 3 | rush &#39;sleep {}; echo {}&#39; -t 3 -c

  $ seq 1 3 | parallel --joblog mylog --timeout 2 \
      &#39;sleep {}; echo {}&#39;
  $ cat mylog
  $ seq 1 3 | parallel --joblog mylog --retry-failed \
      &#39;sleep {}; echo {}&#39;</code></pre>

<p>Multi-line jobs:</p>

<pre><code>  $ seq 1 3 | rush &#39;sleep {}; echo {}; \
    echo finish {}&#39; -t 3 -c -C finished.rush
  $ cat finished.rush
  $ seq 1 3 | rush &#39;sleep {}; echo {}; \
    echo finish {}&#39; -t 3 -c -C finished.rush

  $ seq 1 3 |
      parallel --joblog mylog --timeout 2 &#39;sleep {}; echo {}; \
    echo finish {}&#39;
  $ cat mylog
  $ seq 1 3 |
      parallel --joblog mylog --retry-failed &#39;sleep {}; echo {}; \
        echo finish {}&#39;</code></pre>

<p><b>17. A comprehensive example: downloading 1K+ pages given by three URL list files using `phantomjs save_page.js` (some page contents are dynamicly generated by Javascript, so `wget` does not work). Here I set max jobs number (`-j`) as `20`, each job has a max running time (`-t`) of `60` seconds and `3` retry changes (`-r`). Continue flag `-c` is also switched on, so we can continue unfinished jobs. Luckily, it&#39;s accomplished in one run :)</b></p>

<pre><code>  $ for f in $(seq 2014 2016); do \
  $    /bin/rm -rf $f; mkdir -p $f; \
  $    cat $f.html.txt | rush -v d=$f -d = \
         &#39;phantomjs save_page.js &quot;{}&quot; &gt; {d}/{3}.html&#39; \
         -j 20 -t 60 -r 3 -c; \
  $ done</code></pre>

<p>GNU <b>parallel</b> can append to an existing joblog with &#39;+&#39;:</p>

<pre><code>  $ rm mylog
  $ for f in $(seq 2014 2016); do
      /bin/rm -rf $f; mkdir -p $f;
      cat $f.html.txt |
        parallel -j20 --timeout 60 --retries 4 --joblog +mylog \
          --colsep = \
          phantomjs save_page.js {1}={2}={3} &#39;&gt;&#39; $f/{3}.html
    done</code></pre>

<p><b>18. A bioinformatics example: mapping with `bwa`, and processing result with `samtools`:</b></p>

<pre><code>  $ ref=ref/xxx.fa
  $ threads=25
  $ ls -d raw.cluster.clean.mapping/* \
    | rush -v ref=$ref -v j=$threads -v p=&#39;{}/{%}&#39; \
        &#39;bwa mem -t {j} -M -a {ref} {p}_1.fq.gz {p}_2.fq.gz &gt; {p}.sam; \
        samtools view -bS {p}.sam &gt; {p}.bam; \
        samtools sort -T {p}.tmp -@ {j} {p}.bam -o {p}.sorted.bam; \
        samtools index {p}.sorted.bam; \
        samtools flagstat {p}.sorted.bam &gt; {p}.sorted.bam.flagstat; \
        /bin/rm {p}.bam {p}.sam;&#39; \
        -j 2 --verbose -c -C mapping.rush</code></pre>

<p>GNU <b>parallel</b> would use a function:</p>

<pre><code>  $ ref=ref/xxx.fa
  $ export ref
  $ thr=25
  $ export thr
  $ bwa_sam() {
      p=&quot;$1&quot;
      bam=&quot;$p&quot;.bam
      sam=&quot;$p&quot;.sam
      sortbam=&quot;$p&quot;.sorted.bam
      bwa mem -t $thr -M -a $ref ${p}_1.fq.gz ${p}_2.fq.gz &gt; &quot;$sam&quot;
      samtools view -bS &quot;$sam&quot; &gt; &quot;$bam&quot;
      samtools sort -T ${p}.tmp -@ $thr &quot;$bam&quot; -o &quot;$sortbam&quot;
      samtools index &quot;$sortbam&quot;
      samtools flagstat &quot;$sortbam&quot; &gt; &quot;$sortbam&quot;.flagstat
      /bin/rm &quot;$bam&quot; &quot;$sam&quot;
    }
  $ export -f bwa_sam
  $ ls -d raw.cluster.clean.mapping/* |
      parallel -j 2 --verbose --joblog mylog bwa_sam</code></pre>

<h3 id="Other-rush-features">Other <b>rush</b> features</h3>

<p><b>rush</b> has:</p>

<ul>

<li><p><b>awk -v</b> like custom defined variables (<b>-v</b>)</p>

<p>With GNU <b>parallel</b> you would simply simply set a shell variable:</p>

<pre><code>   parallel &#39;v={}; echo &quot;$v&quot;&#39; ::: foo
   echo foo | rush -v v={} &#39;echo {v}&#39;</code></pre>

<p>Also <b>rush</b> does not like special chars. So these <b>do not work</b>:</p>

<pre><code>   echo does not work | rush -v v=\&quot; &#39;echo {v}&#39;
   echo &quot;My  brother&#39;s  12\&quot;  records&quot; | rush -v v={} &#39;echo {v}&#39;</code></pre>

<p>Whereas the corresponding GNU <b>parallel</b> version works:</p>

<pre><code>   parallel &#39;v=\&quot;; echo &quot;$v&quot;&#39; ::: works
   parallel &#39;v={}; echo &quot;$v&quot;&#39; ::: &quot;My  brother&#39;s  12\&quot;  records&quot;</code></pre>

</li>
<li><p>Exit on first error(s) (-e)</p>

<p>This is called <b>--halt now,fail=1</b> (or shorter: <b>--halt 2</b>) when used with GNU <b>parallel</b>.</p>

</li>
<li><p>Settable records sending to every command (<b>-n</b>, default 1)</p>

<p>This is also called <b>-n</b> in GNU <b>parallel</b>.</p>

</li>
<li><p>Practical replacement strings</p>

<dl>

<dt id="remove-any-extension">{:} remove any extension</dt>
<dd>

<p>With GNU <b>parallel</b> this can be emulated by:</p>

<pre><code>  parallel --plus echo &#39;{/\..*/}&#39; ::: foo.ext.bar.gz</code></pre>

</dd>
<dt id="suffix-remove-suffix">{^suffix}, remove suffix</dt>
<dd>

<p>With GNU <b>parallel</b> this can be emulated by:</p>

<pre><code>  parallel --plus echo &#39;{%.bar.gz}&#39; ::: foo.ext.bar.gz</code></pre>

</dd>
<dt id="regexp-capture-submatch-using-regular-expression">{@regexp}, capture submatch using regular expression</dt>
<dd>

<p>With GNU <b>parallel</b> this can be emulated by:</p>

<pre><code>  parallel --rpl &#39;{@(.*?)} /$$1/ and $_=$1;&#39; \
    echo &#39;{@\d_(.*).gz}&#39; ::: 1_foo.gz</code></pre>

</dd>
<dt id="basename-without-extension">{%.}, {%:}, basename without extension</dt>
<dd>

<p>With GNU <b>parallel</b> this can be emulated by:</p>

<pre><code>  parallel echo &#39;{= s:.*/::;s/\..*// =}&#39; ::: dir/foo.bar.gz</code></pre>

<p>And if you need it often, you define a <b>--rpl</b> in <b>$HOME/.parallel/config</b>:</p>

<pre><code>  --rpl &#39;{%.} s:.*/::;s/\..*//&#39;
  --rpl &#39;{%:} s:.*/::;s/\..*//&#39;</code></pre>

<p>Then you can use them as:</p>

<pre><code>  parallel echo {%.} {%:} ::: dir/foo.bar.gz</code></pre>

</dd>
</dl>

</li>
<li><p>Preset variable (macro)</p>

<p>E.g.</p>

<pre><code>  echo foosuffix | rush -v p={^suffix} &#39;echo {p}_new_suffix&#39;</code></pre>

<p>With GNU <b>parallel</b> this can be emulated by:</p>

<pre><code>  echo foosuffix | parallel --plus &#39;p={%suffix}; echo ${p}_new_suffix&#39;</code></pre>

<p>Opposite <b>rush</b> GNU <b>parallel</b> works fine if the input contains double space, &#39; and &quot;:</p>

<pre><code>  echo &quot;1&#39;6\&quot;  foosuffix&quot; |
    parallel --plus &#39;p={%suffix}; echo &quot;${p}&quot;_new_suffix&#39;</code></pre>

</li>
<li><p>Commands of multi-lines</p>

<p>While you <i>can</i> use multi-lined commands in GNU <b>parallel</b>, to improve readibilty GNU <b>parallel</b> discourages the use of multi-line commands. In most cases it can be written as a function:</p>

<pre><code>  seq 1 3 |
    parallel --timeout 2 --joblog my.log &#39;sleep {}; echo {}; \
      echo finish {}&#39;</code></pre>

<p>Could be written as:</p>

<pre><code>  doit() {
    sleep &quot;$1&quot;
    echo &quot;$1&quot;
    echo finish &quot;$1&quot;
  }
  export -f doit
  seq 1 3 | parallel --timeout 2 --joblog my.log doit</code></pre>

<p>The failed commands can be resumed with:</p>

<pre><code>  seq 1 3 |
    parallel --resume-failed --joblog my.log &#39;sleep {}; echo {};\
      echo finish {}&#39;</code></pre>

</li>
</ul>

<p>https://github.com/shenwei356/rush</p>

<h2 id="DIFFERENCES-BETWEEN-ClusterSSH-AND-GNU-Parallel">DIFFERENCES BETWEEN ClusterSSH AND GNU Parallel</h2>

<p>ClusterSSH solves a different problem than GNU <b>parallel</b>.</p>

<p>ClusterSSH opens a terminal window for each computer and using a master window you can run the same command on all the computers. This is typically used for administrating several computers that are almost identical.</p>

<p>GNU <b>parallel</b> runs the same (or different) commands with different arguments in parallel possibly using remote computers to help computing. If more than one computer is listed in <b>-S</b> GNU <b>parallel</b> may only use one of these (e.g. if there are 8 jobs to be run and one computer has 8 cores).</p>

<p>GNU <b>parallel</b> can be used as a poor-man&#39;s version of ClusterSSH:</p>

<p><b>parallel --nonall -S server-a,server-b do_stuff foo bar</b></p>

<p>https://github.com/duncs/clusterssh</p>

<h2 id="DIFFERENCES-BETWEEN-coshell-AND-GNU-Parallel">DIFFERENCES BETWEEN coshell AND GNU Parallel</h2>

<p><b>coshell</b> only accepts full commands on standard input. Any quoting needs to be done by the user.</p>

<p>Commands are run in <b>sh</b> so any <b>bash</b>/<b>tcsh</b>/<b>zsh</b> specific syntax will not work.</p>

<p>Output can be buffered by using <b>-d</b>. Output is buffered in memory, so big output can cause swapping and therefore be terrible slow or even cause out of memory.</p>

<p>https://github.com/gdm85/coshell</p>

<h2 id="DIFFERENCES-BETWEEN-spread-AND-GNU-Parallel">DIFFERENCES BETWEEN spread AND GNU Parallel</h2>

<p><b>spread</b> runs commands on all directories.</p>

<p>It can be emulated with GNU <b>parallel</b> using this Bash function:</p>

<pre><code>  spread() {
    _cmds() {
      perl -e &#39;$&quot;=&quot; &amp;&amp; &quot;;print &quot;@ARGV&quot;&#39; &quot;cd {}&quot; &quot;$@&quot;
    }
    parallel $(_cmds &quot;$@&quot;)&#39;|| echo exit status $?&#39; ::: */
  }</code></pre>

<p>This works execpt for the <b>--exclude</b> option.</p>

<h2 id="DIFFERENCES-BETWEEN-pyargs-AND-GNU-Parallel">DIFFERENCES BETWEEN pyargs AND GNU Parallel</h2>

<p><b>pyargs</b> deals badly with input containing spaces. It buffers stdout, but not stderr. It buffers in RAM. {} does not work as replacement string. It does not support running functions.</p>

<p><b>pyargs</b> does not support composed commands if run with <b>--lines</b>, and fails on <b>pyargs traceroute gnu.org fsf.org</b>.</p>

<h3 id="Examples">Examples</h3>

<pre><code>  seq 5 | pyargs -P50 -L seq
  seq 5 | parallel -P50 --lb seq

  seq 5 | pyargs -P50 --mark -L seq
  seq 5 | parallel -P50 --lb \
    --tagstring OUTPUT&#39;[{= $_=$job-&gt;replaced()=}]&#39; seq
  # Similar, but not precisely the same
  seq 5 | parallel -P50 --lb --tag seq

  seq 5 | pyargs -P50  --mark command
  # Somewhat longer with GNU Parallel due to the special
  #   --mark formatting
  cmd=&quot;$(echo &quot;command&quot; | parallel --shellquote)&quot;
  wrap_cmd() {
     echo &quot;MARK $cmd $@================================&quot; &gt;&amp;3
     echo &quot;OUTPUT START[$cmd $@]:&quot;
     eval $cmd &quot;$@&quot;
     echo &quot;OUTPUT END[$cmd $@]&quot;
  }
  (seq 5 | env_parallel -P2 wrap_cmd) 3&gt;&amp;1
  # Similar, but not exactly the same
  seq 5 | parallel -t --tag command

  (echo &#39;1  2  3&#39;;echo 4 5 6) | pyargs  --stream seq
  (echo &#39;1  2  3&#39;;echo 4 5 6) | perl -pe &#39;s/\n/ /&#39; |
    parallel -r -d&#39; &#39; seq
  # Similar, but not exactly the same
  parallel seq ::: 1 2 3 4 5 6</code></pre>

<p>https://github.com/robertblackwell/pyargs</p>

<h2 id="DIFFERENCES-BETWEEN-concurrently-AND-GNU-Parallel">DIFFERENCES BETWEEN concurrently AND GNU Parallel</h2>

<p><b>concurrently</b> runs jobs in parallel.</p>

<p>The output is prepended with the job number, and may be incomplete:</p>

<pre><code>  $ concurrently &#39;seq 100000&#39; | (sleep 3;wc -l)
  7165</code></pre>

<p>When pretty printing it caches output in memory. Output mixes by using test MIX below wether or not output is cached.</p>

<p>There seems to be no way of making a template command and have <b>concurrently</b> fill that with different args. The full commands must be given on the command line.</p>

<p>There is also no way of controlling how many jobs should be run in parallel at a time - i.e. &quot;number of jobslots&quot;. Instead all jobs are simply started in parallel.</p>

<p>https://github.com/kimmobrunfeldt/concurrently</p>

<h2 id="DIFFERENCES-BETWEEN-map-soveran-AND-GNU-Parallel">DIFFERENCES BETWEEN map(soveran) AND GNU Parallel</h2>

<p><b>map</b> does not run jobs in parallel by default. The README suggests using:</p>

<pre><code>  ... | map t &#39;sleep $t &amp;&amp; say done &amp;&#39;</code></pre>

<p>But this fails if more jobs are run in parallel than the number of available processes. Since there is no support for parallelization in <b>map</b> itself, the output also mixes:</p>

<pre><code>  seq 10 | map i &#39;echo start-$i &amp;&amp; sleep 0.$i &amp;&amp; echo end-$i &amp;&#39;</code></pre>

<p>The major difference is that GNU <b>parallel</b> is build for parallelization and map is not. So GNU <b>parallel</b> has lots of ways of dealing with the issues that parallelization raises:</p>

<ul>

<li><p>Keep the number of processes manageable</p>

</li>
<li><p>Make sure output does not mix</p>

</li>
<li><p>Make Ctrl-C kill all running processes</p>

</li>
</ul>

<p>Here are the 5 examples converted to GNU Parallel:</p>

<pre><code>  1$ ls *.c | map f &#39;foo $f&#39;
  1$ ls *.c | parallel foo

  2$ ls *.c | map f &#39;foo $f; bar $f&#39;
  2$ ls *.c | parallel &#39;foo {}; bar {}&#39;

  3$ cat urls | map u &#39;curl -O $u&#39;
  3$ cat urls | parallel curl -O

  4$ printf &quot;1\n1\n1\n&quot; | map t &#39;sleep $t &amp;&amp; say done&#39;
  4$ printf &quot;1\n1\n1\n&quot; | parallel &#39;sleep {} &amp;&amp; say done&#39;
  4$ paralllel &#39;sleep {} &amp;&amp; say done&#39; ::: 1 1 1

  5$ printf &quot;1\n1\n1\n&quot; | map t &#39;sleep $t &amp;&amp; say done &amp;&#39;
  5$ printf &quot;1\n1\n1\n&quot; | parallel -j0 &#39;sleep {} &amp;&amp; say done&#39;
  5$ parallel -j0 &#39;sleep {} &amp;&amp; say done&#39; ::: 1 1 1</code></pre>

<p>https://github.com/soveran/map</p>

<h2 id="Todo">Todo</h2>

<p>Url for map, spread</p>

<p>machma. Requires Go &gt;= 1.7.</p>

<p>https://github.com/k-bx/par requires Haskell to work. This limits the number of platforms this can work on.</p>

<p>https://github.com/otonvm/Parallel</p>

<p>https://github.com/flesler/parallel</p>

<p>https://github.com/kou1okada/lesser-parallel</p>

<p>https://github.com/Julian/Verge</p>

<p>https://github.com/amattn/paral</p>

<p>pyargs</p>

<h1 id="TESTING-OTHER-TOOLS">TESTING OTHER TOOLS</h1>

<p>There are certain issues that are very common on parallelizing tools. Here are a few stress tests. Be warned: If the tool is badly coded it may overload you machine.</p>

<h2 id="MIX:-Output-mixes">MIX: Output mixes</h2>

<p>Output from 2 jobs should not mix. If the output is not used, this does not matter; but if the output <i>is</i> used then it is important that you do not get half a line from one job followed by half a line from another job.</p>

<p>If the tool does not buffer, output will most likely mix now and then.</p>

<p>This test stresses whether output mixes.</p>

<pre><code>  #!/bin/bash

  paralleltool=&quot;parallel -j0&quot;

  cat &lt;&lt;-EOF &gt; mycommand
  #!/bin/bash

  # If a, b, c, d, e, and f mix: Very bad
  perl -e &#39;print STDOUT &quot;a&quot;x3000_000,&quot; &quot;&#39;
  perl -e &#39;print STDERR &quot;b&quot;x3000_000,&quot; &quot;&#39;
  perl -e &#39;print STDOUT &quot;c&quot;x3000_000,&quot; &quot;&#39;
  perl -e &#39;print STDERR &quot;d&quot;x3000_000,&quot; &quot;&#39;
  perl -e &#39;print STDOUT &quot;e&quot;x3000_000,&quot; &quot;&#39;
  perl -e &#39;print STDERR &quot;f&quot;x3000_000,&quot; &quot;&#39;
  echo
  echo &gt;&amp;2
  EOF
  chmod +x mycommand

  # Run 30 jobs in parallel
  seq 30 | $paralleltool ./mycommand &gt; &gt;(tr -s abcdef) 2&gt; &gt;(tr -s abcdef &gt;&amp;2)

  # &#39;a c e&#39; and &#39;b d f&#39; should always stay together
  # and there should only be a single line per job</code></pre>

<h2 id="RAM:-Output-limited-by-RAM">RAM: Output limited by RAM</h2>

<p>Some tools cache output in RAM. This makes them extremely slow if the output is bigger than physical memory and crash if the the output is bigger than the virtual memory.</p>

<pre><code>  #!/bin/bash

  paralleltool=&quot;parallel -j0&quot;

  cat &lt;&lt;&#39;EOF&#39; &gt; mycommand
  #!/bin/bash

  # Generate 1 GB output
  yes &quot;`perl -e &#39;print \&quot;c\&quot;x30_000&#39;`&quot; | head -c 1G
  EOF
  chmod +x mycommand

  # Run 20 jobs in parallel
  # Adjust 20 to be &gt; physical RAM and &lt; free space on /tmp
  seq 20 | time $paralleltool ./mycommand | wc -c</code></pre>

<h2 id="DISKFULL:-Incomplete-data-if-tmp-runs-full">DISKFULL: Incomplete data if /tmp runs full</h2>

<p>If caching is done on disk, the disk can run full during the run. Not all programs discover this. GNU Parallel discovers it, if it stays full for at least 2 seconds.</p>

<pre><code>  #!/bin/bash

  paralleltool=&quot;parallel -j0&quot;

  # This should be a dir with less than 100 GB free space
  smalldisk=/tmp/shm/parallel
  
  TMPDIR=&quot;$smalldisk&quot;
  export TMPDIR
  
  max_output() {
      # Force worst case scenario:
      # Make GNU Parallel only check once per second
      sleep 10
      # Generate 100 GB to fill $TMPDIR
      # Adjust if /tmp is bigger than 100 GB
      yes | head -c 100G &gt;$TMPDIR/$$
      # Generate 10 MB output that will not be buffered due to full disk
      perl -e &#39;print &quot;X&quot;x10_000_000&#39; | head -c 10M
      echo This part is missing from incomplete output
      sleep 2
      rm $TMPDIR/$$
      echo Final output
  }
  
  export -f max_output
  seq 10 | $paralleltool max_output | tr -s X</code></pre>

<h2 id="CLEANUP:-Leaving-tmp-files-at-unexpected-death">CLEANUP: Leaving tmp files at unexpected death</h2>

<p>Some tools do not clean up tmp files if they are killed. If the tool buffers on disk, they may not clean up, if they are killed.</p>

<pre><code>  #!/bin/bash

  paralleltool=parallel

  ls /tmp &gt;/tmp/before
  seq 10 | $paralleltool sleep &amp;
  pid=$!
  # Give the tool time to start up
  sleep 1
  # Kill it without giving it a chance to cleanup
  kill -9 $!
  # Should be empty: No files should be left behind
  diff &lt;(ls /tmp) /tmp/before</code></pre>

<h2 id="SPCCHAR:-Dealing-badly-with-special-file-names">SPCCHAR: Dealing badly with special file names.</h2>

<p>It is not uncommon for users to create files like:</p>

<pre><code>  My brother&#39;s 12&quot; *** record  (costs $$$).jpg</code></pre>

<p>Some tools break on this.</p>

<pre><code>  #!/bin/bash

  paralleltool=parallel

  touch &quot;My brother&#39;s 12\&quot; *** record  (costs \$\$\$).jpg&quot;
  ls My*jpg | $paralleltool ls -l</code></pre>

<h2 id="COMPOSED:-Composed-commands-do-not-work">COMPOSED: Composed commands do not work</h2>

<p>Some tools require you to wrap composed commands into <b>bash -c</b>.</p>

<pre><code>  echo bar | $paralleltool echo foo&#39;;&#39; echo {}</code></pre>

<h2 id="ONEREP:-Only-one-replacement-string-allowed">ONEREP: Only one replacement string allowed</h2>

<p>Some tools can only insert the argument once.</p>

<pre><code>  echo bar | $paralleltool echo {} foo {}</code></pre>

<h2 id="NUMWORDS:-Speed-depends-on-number-of-words">NUMWORDS: Speed depends on number of words</h2>

<p>Some tools become very slow if output lines have many words.</p>

<pre><code>  #!/bin/bash

  paralleltool=parallel

  cat &lt;&lt;-EOF &gt; mycommand
  #!/bin/bash

  # 10 MB of lines with 1000 words
  yes &quot;`seq 1000`&quot; | head -c 10M
  EOF
  chmod +x mycommand

  # Run 30 jobs in parallel
  seq 30 | time $paralleltool -j0 ./mycommand &gt; /dev/null</code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>When using GNU <b>parallel</b> for a publication please cite:</p>

<p>O. Tange (2011): GNU Parallel - The Command-Line Power Tool, ;login: The USENIX Magazine, February 2011:42-47.</p>

<p>This helps funding further development; and it won&#39;t cost you a cent. If you pay 10000 EUR you should feel free to use GNU Parallel without citing.</p>

<p>Copyright (C) 2007-10-18 Ole Tange, http://ole.tange.dk</p>

<p>Copyright (C) 2008,2009,2010 Ole Tange, http://ole.tange.dk</p>

<p>Copyright (C) 2010,2011,2012,2013,2014,2015,2016,2017,2018 Ole Tange, http://ole.tange.dk and Free Software Foundation, Inc.</p>

<p>Parts of the manual concerning <b>xargs</b> compatibility is inspired by the manual of <b>xargs</b> from GNU findutils 4.4.2.</p>

<h1 id="LICENSE">LICENSE</h1>

<p>Copyright (C) 2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018 Free Software Foundation, Inc.</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or at your option any later version.</p>

<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</p>

<h2 id="Documentation-license-I">Documentation license I</h2>

<p>Permission is granted to copy, distribute and/or modify this documentation under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is included in the file fdl.txt.</p>

<h2 id="Documentation-license-II">Documentation license II</h2>

<p>You are free:</p>

<dl>

<dt id="to-Share"><b>to Share</b></dt>
<dd>

<p>to copy, distribute and transmit the work</p>

</dd>
<dt id="to-Remix"><b>to Remix</b></dt>
<dd>

<p>to adapt the work</p>

</dd>
</dl>

<p>Under the following conditions:</p>

<dl>

<dt id="Attribution"><b>Attribution</b></dt>
<dd>

<p>You must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of the work).</p>

</dd>
<dt id="Share-Alike"><b>Share Alike</b></dt>
<dd>

<p>If you alter, transform, or build upon this work, you may distribute the resulting work only under the same, similar or a compatible license.</p>

</dd>
</dl>

<p>With the understanding that:</p>

<dl>

<dt id="Waiver"><b>Waiver</b></dt>
<dd>

<p>Any of the above conditions can be waived if you get permission from the copyright holder.</p>

</dd>
<dt id="Public-Domain"><b>Public Domain</b></dt>
<dd>

<p>Where the work or any of its elements is in the public domain under applicable law, that status is in no way affected by the license.</p>

</dd>
<dt id="Other-Rights"><b>Other Rights</b></dt>
<dd>

<p>In no way are any of the following rights affected by the license:</p>

<ul>

<li><p>Your fair dealing or fair use rights, or other applicable copyright exceptions and limitations;</p>

</li>
<li><p>The author&#39;s moral rights;</p>

</li>
<li><p>Rights other persons may have either in the work itself or in how the work is used, such as publicity or privacy rights.</p>

</li>
</ul>

</dd>
</dl>

<dl>

<dt id="Notice"><b>Notice</b></dt>
<dd>

<p>For any reuse or distribution, you must make clear to others the license terms of this work.</p>

</dd>
</dl>

<p>A copy of the full license is included in the file as cc-by-sa.txt.</p>

<h1 id="DEPENDENCIES">DEPENDENCIES</h1>

<p>GNU <b>parallel</b> uses Perl, and the Perl modules Getopt::Long, IPC::Open3, Symbol, IO::File, POSIX, and File::Temp. For remote usage it also uses rsync with ssh.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><b>find</b>(1), <b>xargs</b>(1), <b>make</b>(1), <b>pexec</b>(1), <b>ppss</b>(1), <b>xjobs</b>(1), <b>prll</b>(1), <b>dxargs</b>(1), <b>mdm</b>(1)</p>


</body>

</html>


